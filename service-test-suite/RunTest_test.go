// ********RoostGPT********
/*
Test generated by RoostGPT for test demoTest using AI Type  and AI Model 

ROOST_METHOD_HASH=runTest_858ae49e89
ROOST_METHOD_SIG_HASH=runTest_a2bb790205

Scenario 1: Successful Test Execution

Details:
  Description: This test is meant to check whether the function executes the test correctly when the request is valid and the test is not running in parallel. It also checks the correct status is set after the test is run.
Execution:
  Arrange: Mock the http request and response writer. Prepare a valid ballot.TestReq object. 
  Act: Invoke the runTest function with the mocked http request and response writer.
  Assert: Use Go testing facilities to verify that the status is set to TestStatusOK and TestStatusMap is updated to TestStatusPass. Also, check if the response contains the correct headers.
Validation:
  The choice of assertion is to ensure that the function correctly handles a valid request and updates the status appropriately. This is important to verify the correct execution of tests and the update of test statuses.

Scenario 2: Test Execution with BadRequest

Details:
  Description: This test is meant to check the function's behavior when the request is invalid.
Execution:
  Arrange: Mock the http request and response writer. Prepare an invalid ballot.TestReq object.
  Act: Invoke the runTest function with the mocked http request and response writer.
  Assert: Use Go testing facilities to verify that the status code is set to http.StatusBadRequest.
Validation:
  The choice of assertion is to ensure that the function correctly handles an invalid request. This is important to prevent the execution of tests with invalid parameters.

Scenario 3: Test Execution with TestStatusInProgress

Details:
  Description: This test is meant to check the function's behavior when the test is already in progress and not running in parallel.
Execution:
  Arrange: Mock the http request and response writer. Prepare a valid ballot.TestReq object. Set the TestStatusMap to TestStatusInProgress for the request's url.
  Act: Invoke the runTest function with the mocked http request and response writer.
  Assert: Use Go testing facilities to verify that the status is set to TestStatusNotInvoked.
Validation:
  The choice of assertion is to ensure that the function correctly handles a request when a test is already in progress. This is important to prevent the execution of duplicate tests.

Scenario 4: Test Execution with Timeout

Details:
  Description: This test is meant to check the function's behavior when the test execution times out.
Execution:
  Arrange: Mock the http request and response writer. Prepare a valid ballot.TestReq object with a short timeout.
  Act: Invoke the runTest function with the mocked http request and response writer.
  Assert: Use Go testing facilities to verify that the TestStatusMap is updated to TestStatusTimeOut for the request's url.
Validation:
  The choice of assertion is to ensure that the function correctly handles a timeout scenario. This is important to prevent long-running tests from blocking the execution of other tests. 

Scenario 5: Test Execution with Failure

Details:
  Description: This test is meant to check the function's behavior when the test execution fails.
Execution:
  Arrange: Mock the http request and response writer. Prepare a valid ballot.TestReq object. Make the ballot.RunTest function return an error.
  Act: Invoke the runTest function with the mocked http request and response writer.
  Assert: Use Go testing facilities to verify that the TestStatusMap is updated to TestStatusFailed for the request's url.
Validation:
  The choice of assertion is to ensure that the function correctly handles a test failure. This is important to correctly report the status of failed tests.

*/

// ********RoostGPT********
package main

import (
	"bytes"
	"errors"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/roost-io/roost-example/voting_app/service-test-suite/ballot"
	"github.com/roost-io/roost-example/voting_app/service-test-suite/common"
)

func TestRunTest(t *testing.T) {
	tests := []struct {
		name         string
		request      string
		requestSetup func()
		response     string
	}{
		{
			name:     "Successful Test Execution",
			request:  `{"IP": "127.0.0.1", "Port": "8080"}`,
			response: common.TestStatusOK,
			requestSetup: func() {
				ballot.RunTest = func(req ballot.TestReq) error {
					return nil
				}
			},
		},
		{
			name:     "Test Execution with BadRequest",
			request:  `invalid request`,
			response: http.StatusText(http.StatusBadRequest),
		},
		{
			name:     "Test Execution with TestStatusInProgress",
			request:  `{"IP": "127.0.0.1", "Port": "8080"}`,
			response: common.TestStatusNotInvoked,
			requestSetup: func() {
				common.TestStatusMap["127.0.0.1:8080"] = common.TestStatusInProgress
			},
		},
		{
			name:     "Test Execution with Timeout",
			request:  `{"IP": "127.0.0.1", "Port": "8080", "TimeOut": 1}`,
			response: common.TestStatusTimeOut,
			requestSetup: func() {
				ballot.RunTest = func(req ballot.TestReq) error {
					time.Sleep(2 * time.Second)
					return nil
				}
			},
		},
		{
			name:     "Test Execution with Failure",
			request:  `{"IP": "127.0.0.1", "Port": "8080"}`,
			response: common.TestStatusFailed,
			requestSetup: func() {
				ballot.RunTest = func(req ballot.TestReq) error {
					return errors.New("test failed")
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			common.TestStatusMap = make(map[string]string)
			if tt.requestSetup != nil {
				tt.requestSetup()
			}

			req, err := http.NewRequest("POST", "/runTest", bytes.NewBufferString(tt.request))
			if err != nil {
				t.Fatal(err)
			}

			rr := httptest.NewRecorder()
			handler := http.HandlerFunc(runTest)

			handler.ServeHTTP(rr, req)

			if status := rr.Code; status != http.StatusOK {
				t.Errorf("handler returned wrong status code: got %v want %v", status, http.StatusOK)
			}

			if response := strings.TrimSuffix(rr.Body.String(), "\n"); response != tt.response {
				t.Errorf("handler returned unexpected body: got %v want %v", response, tt.response)
			}
		})
	}
}
